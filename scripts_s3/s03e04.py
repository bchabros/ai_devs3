import httpximport jsonimport osfrom enum import Enumfrom openai import OpenAIfrom dotenv import load_dotenvfrom src.send_task import sendfrom src.prompt.s03e04 import SYSTEM_PROMPTfrom loguru import logger# Configuration and Environment Setupload_dotenv()class Config:    API_KEY = os.environ.get("API_KEY")    CENTRAL_URL = os.environ.get("CENTRALA_URL")    OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")    @classmethod    def get_url(cls, endpoint: str) -> str:        return f"{cls.CENTRAL_URL}/{endpoint}"    @classmethod    def validate_config(cls):        """Validate all required environment variables are set"""        missing_vars = []        for var in ["API_KEY", "CENTRALA_URL", "OPENAI_API_KEY"]:            if not getattr(cls, var):                missing_vars.append(var)        if missing_vars:            logger.error(f"Missing required environment variables: {', '.join(missing_vars)}")            raise ValueError("Missing required environment variables")class QueryType(str, Enum):    PEOPLE = "people"    PLACES = "places"    @classmethod    def has_value(cls, value):        return value in [item.value for item in cls]class DatabaseClient:    @staticmethod    def fetch_text(url: str) -> str | None:        """Fetch text content from URL"""        logger.info(f"Fetching text from URL: {url}")        try:            response = httpx.get(url)            response.encoding = 'utf-8'            logger.success(f"Successfully fetched {len(response.text)} characters from URL")            return response.text        except Exception as e:            logger.error(f"Error fetching text: {e}")            return None    @staticmethod    def query_db(query_type: QueryType, query: str) -> dict:        """Send query to Database API"""        logger.info(f"Querying database - Type: {query_type}, Query: {query}")        if not QueryType.has_value(query_type):            logger.error(f"Invalid query type: {query_type}")            raise ValueError(f"Invalid query type {query_type}")        data = {            "apikey": Config.API_KEY,            "query": query        }        url = Config.get_url(query_type)        response = httpx.post(url, data=json.dumps(data))        return response.json()class OpenAITools:    TOOLS = [        {            "type": "function",            "function": {                "name": "query_db",                "description": "Query the database for a person or place",                "parameters": {                    "type": "object",                    "properties": {                        "query_type": {                            "type": "string",                            "description": "Query type (people/places)",                        },                        "query": {                            "type": "string",                            "description": "Query (single word in uppercase without diacritics)"                        }                    },                    "required": ["query_type", "query"],                    "additionalProperties": False                }            }        }    ]class Agent:    def __init__(self):        logger.info("Initializing Agent")        self.llm = OpenAI(api_key=Config.OPENAI_API_KEY)        self.database = DatabaseClient()        self.note = self._fetch_note()    def _fetch_note(self) -> str:        """Fetch and return the note content"""        note_url = "https://centrala.ag3nts.org/dane/barbara.txt"        note_content = self.database.fetch_text(note_url)        if note_content is None:            logger.error("Failed to fetch NOTE content. Using empty string.")            return ""        return note_content    def _get_base_messages(self, history=None):        logger.debug(f"Creating base messages with history length: {len(history) if history else 0}")        return [            {                "role": "system",                "content": SYSTEM_PROMPT.format(note=self.note),            },            {                "role": "system",                "content": f"<HISTORY>{json.dumps(history or [])}</HISTORY>"            }        ]    @staticmethod    def _extract_solution_status(message_content: str) -> bool:        """        Extract whether a solution has been found from the message content.        Returns True if 'DONE' is in the message, indicating solution found.        """        if message_content is None:            logger.warning("Received None message content while checking solution status")            return False        solution_found = "DONE" in message_content        if solution_found:            logger.success("Solution found in message content!")        else:            logger.debug("No solution found in current message")        return solution_found    @staticmethod    def _handle_tool_calls(completion) -> list:        """Extract tool calls from completion response"""        for choice in completion.choices:            if choice.finish_reason == "tool_calls":                return choice.message.tool_calls        return []    def process_step(self, history=None):        """Process single agent step"""        logger.info("Starting new processing step")        if history is None:            history = []        logger.debug("Preparing messages for LLM")        messages = self._get_base_messages(history)        try:            logger.info("Sending request to OpenAI")            response = self.llm.chat.completions.create(                model="gpt-4o",                messages=messages,                tools=OpenAITools.TOOLS            )            logger.success("Received response from OpenAI")        except Exception as e:            logger.error(f"Error getting LLM response: {str(e)}")            raise        # Handle case with no tool calls        if not response.choices[0].message.tool_calls:            message_content = response.choices[0].message.content            logger.info("No tool calls in response. Checking for solution")            logger.debug(f"Message content: {message_content}")            logger.info(f"No tool calls. Message: {message_content}")            solution_found = self._extract_solution_status(message_content)            return history, solution_found        # Process tool calls        calls = self._handle_tool_calls(response)        logger.info(f"Processing {len(calls)} tool calls")        call_results = []        for call_ in calls:            try:                args = json.loads(call_.function.arguments)                logger.info(f"Executing tool call - Function: {call_.function.name}, Arguments: {args}")                result = self.database.query_db(**args)                call_results.append({                    "call_id": call_.id,                    "call_kwargs": args,                    "call_result": result                })                logger.success(f"Tool call {call_.id} executed successfully")            except Exception as e:                logger.error(f"Error executing tool call {call_.id}: {str(e)}")                raise        history.append({"history_step_num": len(history), "calls": call_results})        logger.debug(f"Updated history with {len(call_results)} new calls")        return history, Falsedef main():    logger.info("Starting main execution...")    try:        agent = Agent()        history = None        solution_found = False        max_iterations = 20        iteration = 0        while not solution_found and iteration < max_iterations:            logger.info(f"Starting iteration {iteration + 1}/{max_iterations}")            history, solution_found = agent.process_step(history)            if history:                logger.info(f"Completed iteration {iteration + 1} - History size: {len(history)}")            iteration += 1        if solution_found:            logger.success("Solution found! Sending final report...")            report_url = Config.get_url("report")            result = send(                url=report_url,                answer="ELBLAG",                apikey=Config.API_KEY,                task="loop"            )            logger.success(f"Report sent successfully: {result}")        else:            logger.warning(f"No solution found after {max_iterations} iterations")    except Exception as e:        logger.error(f"Fatal error in main execution: {str(e)}", exc_info=True)        raise    logger.info("Main execution completed")if __name__ == "__main__":    main()