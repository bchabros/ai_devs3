import osimport openaifrom openai import OpenAIimport requestsfrom typing import List, Dictimport jsonimport asynciofrom dataclasses import dataclassfrom dotenv import load_dotenvfrom loguru import logger@dataclassclass Conversation:    id: str    start: str    end: str    length: int    reconstructed: List[str] = Noneclass ConversationReconstructor:    def __init__(self, api_key: str):        self.api_key = api_key        openai.api_key = api_key    async def reconstruct_conversations(self, data: Dict) -> Dict:        logger.info("Starting to reconstruct conversations.")        conversations = {}        remaining_lines = data["reszta"]        # Initialize conversations with start and end        for conv_id, conv_data in data.items():            if conv_id != "reszta":                conversations[conv_id] = {                    "lines": [conv_data["start"]],                    "length": conv_data["length"],                    "end": conv_data["end"],                }        # Iteratively build conversations        for current_conv_id in conversations.keys():            while len(conversations[current_conv_id]["lines"]) < conversations[current_conv_id]["length"] - 1:                next_line = await self._find_next_line(                    current_conv_id,                    conversations[current_conv_id]["lines"][-1],                    remaining_lines,                    conversations[current_conv_id]["end"],                )                if next_line:                    conversations[current_conv_id]["lines"].append(next_line)                    remaining_lines.remove(next_line)                else:                    break            # Add the end line            conversations[current_conv_id]["lines"].append(conversations[current_conv_id]["end"])        logger.info("Finished reconstructing conversations.")        return {k: v["lines"] for k, v in conversations.items()}    async def _find_next_line(            self, conv_id: str, current_line: str, available_lines: List[str], end_line: str    ) -> str:        """Find the next logical line in the conversation"""        logger.debug(f"Finding next line: convo_id={conv_id}, last_line={current_line}")        logger.debug(f"Available lines: {json.dumps(available_lines, indent=2)}")        prompt = (f"Find the next logical line after {current_line} in conversation {conv_id}. "                  f"End with {end_line}. Lines: {available_lines}")        try:            suggested_line = self.get_next_line_from_api(prompt)            # Verify the suggested line exists in available lines            for line in available_lines:                if line.strip() == suggested_line:                    return line            return None        except Exception as e:            logger.error(f"Error in finding next line: {e}")            return None    def get_next_line_from_api(self, prompt: str) -> str:        logger.debug("Calling OpenAI API for next line suggestion.")        client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))        try:            response = client.chat.completions.create(                model="gpt-4o",                messages=[                    {                        "role": "system",                        "content": "You are a conversation analysis expert focused on finding logical connections between conversation pieces.",                    },                    {"role": "user", "content": prompt},                ],            )        except Exception as e:            logger.error(f"Error calling OpenAI API: {e}")            raise        logger.debug("Received response from OpenAI API.")        return response.choices[0].message.content.strip()async def main():    # Initialize    load_dotenv()    response = requests.get("https://centrala.ag3nts.org/data/41e8fc1b-1faf-4de8-957f-dd82ba32c720/phone.json")    data = response.json()    reconstructor = ConversationReconstructor(os.getenv("OPENAI_API_KEY"))    # Reconstruct conversations    conversations = await reconstructor.reconstruct_conversations(data)    # Save results    with open("output.json", "w", encoding="utf-8") as f:        json.dump(conversations, f, ensure_ascii=False, indent=4)if __name__ == "__main__":    asyncio.run(main())