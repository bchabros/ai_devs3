import refrom typing import Optionalimport httpximport jsonimport osfrom enum import Enumfrom openai import OpenAIfrom dotenv import load_dotenvfrom src.prompt.s03e04 import SYSTEM_PROMPTfrom loguru import loggerfrom dataclasses import dataclass# Configuration and Environment Setupload_dotenv()class Config:    """Configuration management class"""    API_KEY = os.environ.get("API_KEY")    CENTRALA_URL = os.environ.get("CENTRALA_URL")    OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")    @classmethod    def get_url(cls, endpoint: str) -> str:        return f"{cls.CENTRALA_URL}/{endpoint}"    @classmethod    def validate_config(cls):        """Validate all required environment variables are set"""        missing_vars = []        for var in ["API_KEY", "CENTRALA_URL", "OPENAI_API_KEY"]:            if not getattr(cls, var):                missing_vars.append(var)        if missing_vars:            logger.error(f"Missing required environment variables: {', '.join(missing_vars)}")            raise ValueError("Missing required environment variables")class QueryType(str, Enum):    PEOPLE = "people"    PLACES = "places"    @classmethod    def has_value(cls, value):        return value in [item.value for item in cls]@dataclassclass AgentResponse:    """Structured response from the agent's analysis"""    reasoning: str    action: Optional[str] = None    target: Optional[str] = None    target_city: Optional[str] = None    is_final: bool = False    @classmethod    def from_message(cls, message: Optional[str]) -> 'AgentResponse':        """Parse agent response from message content"""        if not message:            logger.warning("Received empty message content")            return cls(reasoning="No message content provided")        reasoning_match = re.search(r"REASONING:\s*(.+?)(?=\n|$)", message)        action_match = re.search(r"ACTION:\s*(.+?)(?=\n|$)", message)        target_match = re.search(r"TARGET:\s*(.+?)(?=\n|$)", message)        final_city_match = re.search(r"FINAL_CITY:\s*([A-Z]+)(?=\n|$)", message)        is_final_match = re.search(r"IS_FINAL:\s*(true|false)", message, re.IGNORECASE)        done_match = re.search(r"DONE", message)        return cls(            reasoning=reasoning_match.group(1).strip() if reasoning_match else "No reasoning provided",            action=action_match.group(1).strip() if action_match else None,            target=target_match.group(1).strip() if target_match else None,            target_city=final_city_match.group(1) if final_city_match else None,            is_final=bool(is_final_match and is_final_match.group(1).lower() == "true" or done_match)        )class DatabaseClient:    """Client for handling database operations"""    @staticmethod    def fetch_text(url: str) -> str | None:        """Fetch text content from URL"""        logger.info(f"Fetching text from URL: {url}")        try:            response = httpx.get(url)            response.encoding = 'utf-8'            logger.success(f"Successfully fetched {len(response.text)} characters from URL")            return response.text        except Exception as e:            logger.error(f"Error fetching text: {e}")            return None    @staticmethod    def query_db(query_type: QueryType, query: str) -> dict:        """Send query to Database API"""        query = query.strip().split()[0]        logger.info(f"Querying database - Type: {query_type}, Query: {query}")        if not QueryType.has_value(query_type):            logger.error(f"Invalid query type: {query_type}")            raise ValueError(f"Invalid query type {query_type}")        data = {            "apikey": Config.API_KEY,            "query": query        }        url = Config.get_url(query_type)        response = httpx.post(url, data=json.dumps(data))        return response.json()class OpenAITools:    TOOLS = [        {            "type": "function",            "function": {                "name": "query_db",                "description": "Query the database for a person or place",                "parameters": {                    "type": "object",                    "properties": {                        "query_type": {                            "type": "string",                            "description": "Query type (people/places)",                        },                        "query": {                            "type": "string",                            "description": "Query (single word in uppercase without diacritics)"                        }                    },                    "required": ["query_type", "query"],                    "additionalProperties": False                }            }        }    ]class Agent:    """Main agent class for processing and analyzing data"""    def __init__(self):        logger.info("Initializing Agent")        self.llm = OpenAI(api_key=Config.OPENAI_API_KEY)        self.database = DatabaseClient()        self.note = self._fetch_note()        self.current_reasoning: Optional[str] = None        self.found_city: Optional[str] = None    def _fetch_note(self) -> str:        """Fetch and return the note content"""        note_url = f"{os.getenv('CENTRALA_URL')}dane/barbara.txt"        note_content = self.database.fetch_text(note_url)        if note_content is None:            logger.error("Failed to fetch NOTE content. Using empty string.")            return ""        return note_content    def _get_base_messages(self, history=None):        logger.debug(f"Creating base messages with history length: {len(history) if history else 0}")        return [            {                "role": "system",                "content": SYSTEM_PROMPT.format(note=self.note),            },            {                "role": "system",                "content": f"<HISTORY>{json.dumps(history or [])}</HISTORY>"            }        ]    @staticmethod    def _extract_solution_status(message_content: str) -> bool:        """        Extract whether a solution has been found from the message content.        Returns True if 'DONE' is in the message, indicating solution found.        """        if message_content is None:            logger.warning("Received None message content while checking solution status")            return False        solution_found = "DONE" in message_content        if solution_found:            logger.success("Solution found in message content!")        else:            logger.debug("No solution found in current message")        return solution_found    @staticmethod    def _handle_tool_calls(completion) -> list:        """Extract tool calls from completion response"""        for choice in completion.choices:            if choice.finish_reason == "tool_calls":                return choice.message.tool_calls        return []    def process_step(self, history=None):        """Process single agent step"""        logger.info("Starting new processing step")        if history is None:            history = []        messages = self._get_base_messages(history)        try:            response = self.llm.chat.completions.create(                model="gpt-4o",                messages=messages,                tools=OpenAITools.TOOLS            )            logger.success("Received response from OpenAI")            # Parse the response            message_content = response.choices[0].message.content            agent_response = AgentResponse.from_message(message_content)            # Log the reasoning            logger.info(f"Agent reasoning: {agent_response.reasoning}")            self.current_reasoning = agent_response.reasoning            if agent_response.is_final:                self.found_city = agent_response.target_city                logger.success(f"Solution found! Target city: {self.found_city}")                return history, True            # Handle tool calls if present            if hasattr(response.choices[0].message, 'tool_calls') and response.choices[0].message.tool_calls:                tool_calls = response.choices[0].message.tool_calls                call_results = []                for call in tool_calls:                    try:                        args = json.loads(call.function.arguments)                        logger.info(f"Executing tool call - Function: {call.function.name}, Arguments: {args}")                        result = self.database.query_db(**args)                        call_results.append({                            "call_id": call.id,                            "call_kwargs": args,                            "call_result": result,                            "reasoning": self.current_reasoning                        })                        logger.success(f"Tool call {call.id} executed successfully")                    except Exception as e:                        logger.error(f"Error executing tool call {call.id}: {str(e)}")                        raise                history.append({                    "history_step_num": len(history),                    "calls": call_results,                    "reasoning": self.current_reasoning                })            else:                # If no tool calls and not final, still capture the reasoning                history.append({                    "history_step_num": len(history),                    "calls": [],                    "reasoning": self.current_reasoning                })            return history, False        except Exception as e:            logger.error(f"Error processing step: {str(e)}")            raise    def get_final_city(self) -> Optional[str]:        """Return the found city if solution was found"""        return self.found_citydef send_report(city: str) -> dict:    """Send final report to the API"""    report_url = Config.get_url("report")    return httpx.post(        report_url,        json={            "apikey": Config.API_KEY,            "answer": city,            "task": "loop"        }    ).json()