import osfrom dotenv import load_dotenvfrom loguru import loggerfrom src.send_task import send_queryfrom pydantic import BaseModelfrom typing import Listclass Connection(BaseModel):    user1_id: int    user2_id: intclass User(BaseModel):    id: int    username: str    access_level: str    is_active: int    lastlog: strdef load_config():    """    Loads environment configuration values.    Returns:        dict: A dictionary containing configuration values including the centrala_url, api_key, neo4j_uri, and neo4j_auth.    """    logger.debug("Loading configuration from environment variables")    load_dotenv()    return {        'centrala_url': os.getenv('CENTRALA_URL'),        'api_key': os.getenv('API_KEY'),        'neo4j_uri': "neo4j://localhost:7687",        'neo4j_auth': (os.getenv("NEO4J_USER"), os.getenv("NEO4J_PASSWORD"))    }def fetch_data(config):    """    Fetches data from the API based on the provided configuration.    Args:        config (dict): The configuration dictionary containing API details.    Returns:        tuple: A tuple containing a list of Connection objects and a list of User objects.    """    logger.debug(f"Fetching data with config: {config}")    connections = send_query(        f"{config['centrala_url']}apidb",        apikey=config['api_key'],        query="select * from connections"    )    users = send_query(        f"{config['centrala_url']}apidb",        apikey=config['api_key'],        query="select * from users"    )    logger.debug("Data fetched successfully")    return (        [Connection(**conn) for conn in connections.reply],        [User(**user) for user in users.reply]    )def add_user_tx(tx, user: User):    """    Adds a user to the Neo4j database within a transaction.    Args:        tx: The transaction object.        user (User): The user object to be added.    Returns:        Result: The result of the Cypher query execution.    """    logger.debug(f"Adding user to database: {user}")    query = """    MERGE (u:User {        id: $id,        username: $username,        accessLevel: $access_level,        isActive: $is_active,        lastlog: $lastlog    })    """    return tx.run(        query,        id=user.id,        username=user.username,        access_level=user.access_level,        is_active=user.is_active,        lastlog=user.lastlog    )def add_user_relationship(tx, user_a: int, user_b: int):    """    Adds a relationship between two users in the Neo4j database within a transaction.    Args:        tx: The transaction object.        user_a (int): The ID of the first user.        user_b (int): The ID of the second user.    Returns:        Result: The result of the Cypher query execution.    """    logger.debug(f"Adding relationship between user {user_a} and user {user_b}")    query = """    MATCH (ua:User {id:$id_a})    MATCH (ub:User {id:$id_b})    MERGE (ua)-[r:KNOWS]->(ub)    """    return tx.run(query, id_a=user_a, id_b=user_b)def find_shortest_path_tx(tx, id_a: int, id_b: int):    """    Finds the shortest path between two users in the Neo4j database within a transaction.    Args:        tx: The transaction object.        id_a (int): The ID of the starting user.        id_b (int): The ID of the ending user.    Returns:        Result: The result containing the shortest path.    """    logger.debug(f"Finding shortest path between user {id_a} and user {id_b}")    query = """    MATCH p = shortestPath((ua:User)-[:KNOWS*]->(ub:User))    WHERE ua.id = $id_a AND ub.id = $id_b    RETURN p AS result    """    result = tx.run(query, id_a=id_a, id_b=id_b)    return result.single()def populate_database(driver, users: List[User], connections: List[Connection]):    """    Populates the Neo4j database with users and their connections.    Args:        driver: The Neo4j driver object.        users (List[User]): A list of User objects to be added.        connections (List[Connection]): A list of Connection objects representing user relationships.    Returns:        None    """    logger.info(f"Starting to populate database with {len(users)} users and {len(connections)} connections")    with driver.session(database="neo4j") as session:        for user in users:            logger.debug(f"Adding user: {user}")            session.execute_write(add_user_tx, user=user)        for conn in connections:            logger.debug(f"Adding connection between users: {conn.user1_id} and {conn.user2_id}")            session.execute_write(add_user_relationship, user_a=conn.user1_id, user_b=conn.user2_id)def find_path_between_users(driver, users: List[User], user1_name: str, user2_name: str):    """    Finds the shortest path between two users by their usernames.    Args:        driver: The Neo4j driver object.        users (List[User]): A list of User objects.        user1_name (str): The username of the starting user.        user2_name (str): The username of the ending user.    Returns:        Result: The result containing the shortest path.    """    logger.debug(f"Finding path between users '{user1_name}' and '{user2_name}'")    user_a = next(user for user in users if user.username == user1_name)    user_b = next(user for user in users if user.username == user2_name)    with driver.session(database="neo4j") as session:        result = session.execute_read(find_shortest_path_tx, id_a=user_a.id, id_b=user_b.id)        logger.debug("Shortest path found successfully")        return resultdef format_path_result(result):    """    Formats the result of the shortest path query into a readable string.    Args:        result: The result object containing the shortest path.    Returns:        str: A comma-separated string of usernames in the shortest path.    """    logger.debug("Formatting the path result")    return ", ".join([        item[1]        for node in result["result"].nodes        for item in node.items()        if item[0] == "username"    ])